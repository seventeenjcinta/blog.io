---
layout: post
title: bzoj - 4810
date: 2018-03-15
categories: blog
tags: [ACM,莫队,bitset]
description: 挡不住风霜
header-img: "img/bzoj4810C.jpg"
---




<center><h1><font face="verdana" color="red"> [Ynoi2017]由乃的玉米田 </font></h1></center>

<center><font size="3" face="arial"> Time Limit: 30000MS </font></center>	 
<center><font size="3" face="arial"> Memory Limit: 256 MB </font></center>	 	



### Description

由乃在自己的农田边散步，她突然发现田里的一排玉米非常的不美。这排玉米一共有N株，它们的高度参差不齐。
由乃认为玉米田不美，所以她决定出个数据结构题<br>
 
这个题是这样的：<br>
给你一个序列a，长度为n，有m次操作，每次询问一个区间是否可以选出两个数它们的差为x，或者询问一个区间是否可以选出两个数它们的和为x，或者询问一个区间是否可以选出两个数它们的乘积为x ，这三个操作分别为操作1
,2,3选出的这两个数可以是同一个位置的数
![avater](https://raw.githubusercontent.com/seventeenjcinta/seventeenjcinta.GitHub.io/master/img/vv1(4).jpg)

### Input

第一行两个数n,m<br>
后面一行n个数表示ai<br>
后面m行每行四个数opt l r x<br>
opt表示这个是第几种操作，l,r表示操作的区间，x表示这次操作的x<br>
定义c为每次的x和ai中的最大值，ai >= 0，每次的x>=2，n,m,c <= 100000<br>

### Output

对于每个询问，如果可以，输出yuno，否则输出yumi<br>

### Sample Input

5 5<br>
1 1 2 3 4<br>
2 1 1 2<br>
1 1 2 2<br>
3 1 1 1<br>
3 5 5 16<br>
1 2 3 4<br>

### Sample Output

yuno<br>
yumi<br>
yuno<br>
yuno<br>
yumi<br>



***
刚开始觉得是一个题意杀<br>

后来觉得其实很好理解的<br>
总觉得似曾相识<br>

一个人每天都要堆一个重量为 ma[i] 的雪人<br>
每天每堆雪人都会融化 mb[i]<br>
对于同一天是先堆雪人后融化<br>
当然如果一个雪人已经没了肯定就不会再融化了<br>

最后让你输出每天共融化了多少重量的雪<br>

刚开始想着往数据结构方面去想<br>
毕竟雪人的融化可以当作区间减<br>
但是失败了= =<br>

然后开始重新想<br>
下意识的觉得应该来一个前缀和<br>
然后就出来了<br>

首先要知道一点<br>

如果每个雪人体积是无限的<br>
那么第 i 天融化的雪就是 mb[i] * i<br>

然后有两个点会影响这个值

第一就是如果之前已经有雪人融化了，那么

我们对每天融化的雪来做一个前缀和<br>

然后对于第 i 天堆其来的雪人<br>
我们尝试去求出它在第几天会彻底融化<br>

怎么求呢<br>

当然是对于 (ma[i] + sum_mb[i  1]) 在 sum_mb 中二分啦<br>

找到 sum_mb 中第一个大于他的数的下标 x<br>
这就意味着在第 x 天这个雪人融化了<br>

那么在那一天融化的雪就是 cnt * mb[x] - (sum_mb[x] - ma[i])<br>
注意到这边用的是 cnt<br>
因为有雪人融化<br>
所以我们还要维护一下当前存在的雪人的个数<br>

最后很显然会爆 int<br>
比赛的时候懒得思考了<br>
全换了 longlong！<br>


<pre><code>
#include &lt;bits/stdc++.h&gt;
#define LL long long
using namespace std;

const int N = 100010;

int ma[N];
int mb[N];
LL mc[N];
LL cnt1[N];
int cnt2[N];
int n;
int cnt;

int main(int argc, char const *argv[])
{
	while(scanf("%lld", &n) == 1){
	    ma[0] = mb[0] = 0;
	    cnt = 1;
	    memset(cnt1, 0, sizeof(cnt1));
	    memset(cnt2, 0, sizeof(cnt2));
	    for(int i = 1; i <= n; i ++){
	    	scanf("%d", &ma[i]);
    	    }
	    for(int i = 1; i <= n; i ++){
		scanf("%lld", &mb[i]);
		mc[i] = mb[i];
		mc[i] += mc[i - 1];
	    }
	    for(int i = 1; i <= n; i ++){
		int l, r;
		int ans;

		l = i;
		r = n;
		ans = -1;
		while(l <= r){
		    int mid;

                    mid = (l + r) >> 1;
	     	    if(mc[mid] - mc[i - 1] < ma[i]){
                        l = mid + 1;
	    	    }
		    else{
                        r = mid - 1;
                        ans = mid;
	  	    }
		}
		if(ans != -1){
                    cnt1[ans] -= (ma[i] - mc[ans] + mc[i - 1]);
                    cnt2[ans] ++;
		}
	    }
    	    for(int i = 1; i <= n; i ++){
                printf("%lld ", 1ll * cnt * mb[i] - cnt1[i]);
                cnt ++;
                cnt -= cnt2[i];
	    }
	    printf("\n");
	}

	return 0;
}
