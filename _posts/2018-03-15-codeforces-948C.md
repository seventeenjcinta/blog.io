---
layout: post
title: codeforces - 948C
date: 2018-03-15
categories: blog
tags: [ACM,思维,二分]
description: 挡不住风霜
header-img: "img/codeforces948C.jpg"
---




<center><h1><font face="verdana" color="red"> Volleyball </font></h1></center>

<center><font size="3" face="arial"> Time Limit: 2000MS </font></center>	 
<center><font size="3" face="arial"> Memory Limit: 256 megabytes </font></center>	 	



### Description

Petya loves volleyball very much. One day he was running late for a volleyball match. Petya hasn't bought his own car yet, that's why he had to take a taxi. The city has n junctions, some of which are connected by two-way roads. The length of each road is defined by some positive integer number of meters; the roads can have different lengths.

Initially each junction has exactly one taxi standing there. The taxi driver from the i-th junction agrees to drive Petya (perhaps through several intermediate junctions) to some other junction if the travel distance is not more than ti meters. Also, the cost of the ride doesn't depend on the distance and is equal to ci bourles. Taxis can't stop in the middle of a road. Each taxi can be used no more than once. Petya can catch taxi only in the junction, where it stands initially.

At the moment Petya is located on the junction x and the volleyball stadium is on the junction y. Determine the minimum amount of money Petya will need to drive to the stadium.

### Input

The first line contains two integers n and m (1 ≤ n ≤ 1000, 0 ≤ m ≤ 1000). They are the number of junctions and roads in the city correspondingly. The junctions are numbered from 1 to n, inclusive. The next line contains two integers x and y (1 ≤ x, y ≤ n). They are the numbers of the initial and final junctions correspondingly. Next m lines contain the roads' description. Each road is described by a group of three integers ui, vi, wi (1 ≤ ui, vi ≤ n, 1 ≤ wi ≤ 109) — they are the numbers of the junctions connected by the road and the length of the road, correspondingly. The next n lines contain n pairs of integers ti and ci (1 ≤ ti, ci ≤ 109), which describe the taxi driver that waits at the i-th junction — the maximum distance he can drive and the drive's cost. The road can't connect the junction with itself, but between a pair of junctions there can be more than one road. All consecutive numbers in each line are separated by exactly one space character.

### Output

If taxis can't drive Petya to the destination point, print "-1" (without the quotes). Otherwise, print the drive's minimum cost.

Please do not use the %lld specificator to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specificator.

### Sample Input

4 4<br>
1 3<br>
1 2 3<br>
1 4 1<br>
2 4 1<br>
2 3 5<br>
2 7<br>
7 2<br>
1 2<br>
7 7<br>

### Sample Output

9<br>



***
刚开始觉得是一个题意杀<br>

后来觉得其实很好理解的<br>
总觉得似曾相识<br>

一个人每天都要堆一个重量为 ma[i] 的雪人<br>
每天每堆雪人都会融化 mb[i]<br>
对于同一天是先堆雪人后融化<br>
当然如果一个雪人已经没了肯定就不会再融化了<br>

最后让你输出每天共融化了多少重量的雪<br>

刚开始想着往数据结构方面去想<br>
毕竟雪人的融化可以当作区间减<br>
但是失败了= =<br>

然后开始重新想<br>
下意识的觉得应该来一个前缀和<br>
然后就出来了<br>

首先要知道一点<br>

如果每个雪人体积是无限的<br>
那么第 i 天融化的雪就是 mb[i] * i<br>

然后有两个点会影响这个值

第一就是如果之前已经有雪人融化了，那么

我们对每天融化的雪来做一个前缀和<br>

然后对于第 i 天堆其来的雪人<br>
我们尝试去求出它在第几天会彻底融化<br>

怎么求呢<br>

当然是对于 (ma[i] + sum_mb[i  1]) 在 sum_mb 中二分啦<br>

找到 sum_mb 中第一个大于他的数的下标 x<br>
这就意味着在第 x 天这个雪人融化了<br>

那么在那一天融化的雪就是 cnt * mb[x] - (sum_mb[x] - ma[i])<br>
注意到这边用的是 cnt<br>
因为有雪人融化<br>
所以我们还要维护一下当前存在的雪人的个数<br>

最后很显然会爆 int<br>
比赛的时候懒得思考了<br>
全换了 longlong！<br>


<pre><code>
#include &lt;bits/stdc++.h&gt;
#define LL long long
using namespace std;

const int N = 100010;

int ma[N];
int mb[N];
LL mc[N];
LL cnt1[N];
int cnt2[N];
int n;
int cnt;

int main(int argc, char const *argv[])
{
	while(scanf("%lld", &n) == 1){
	    ma[0] = mb[0] = 0;
	    cnt = 1;
	    memset(cnt1, 0, sizeof(cnt1));
	    memset(cnt2, 0, sizeof(cnt2));
	    for(int i = 1; i <= n; i ++){
	    	scanf("%d", &ma[i]);
    	    }
	    for(int i = 1; i <= n; i ++){
		scanf("%lld", &mb[i]);
		mc[i] = mb[i];
		mc[i] += mc[i - 1];
	    }
	    for(int i = 1; i <= n; i ++){
		int l, r;
		int ans;

		l = i;
		r = n;
		ans = -1;
		while(l <= r){
		    int mid;

                    mid = (l + r) >> 1;
	     	    if(mc[mid] - mc[i - 1] < ma[i]){
                        l = mid + 1;
	    	    }
		    else{
                        r = mid - 1;
                        ans = mid;
	  	    }
		}
		if(ans != -1){
                    cnt1[ans] -= (ma[i] - mc[ans] + mc[i - 1]);
                    cnt2[ans] ++;
		}
	    }
    	    for(int i = 1; i <= n; i ++){
                printf("%lld ", 1ll * cnt * mb[i] - cnt1[i]);
                cnt ++;
                cnt -= cnt2[i];
	    }
	    printf("\n");
	}

	return 0;
}
